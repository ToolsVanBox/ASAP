params {
  dummy = 'None'
}

cache = 'lenient'

plugins {
  id 'nf-validation'
}

executor {
    $sge {
      queueSize = 1000
      pollInterval = '30sec'
      queueStatInterval = '5min'
    }
    $slurm {
      queueSize = 1000
      pollInterval = '30sec'
      queueStatInterval = '5min'
    }
}

def getGcpProject() {
    def proc = "gcloud config get-value project".execute()
    proc.waitFor()
    return proc.in.text.trim()
}

def getMetadataNetwork() {
    try {
        def cmd = ["curl", "-s", "-f", "-H", "Metadata-Flavor: Google", "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/network"]
        def proc = cmd.execute()
        proc.waitFor()
        if (proc.exitValue() == 0) {
            return proc.in.text.trim()
        }
    } catch (Exception e) {
        System.err.println "WARNING: Could not fetch network metadata: ${e.message}"
    }
    return null
}

profiles {
  sge {
    process.executor = 'sge'
    process.queue = 'all.q'
    process.clusterOptions = '-P pmc_vanboxtel '
  }

  local {
    process.executor = 'local'
    params.resource_dir = "/hpc/pmc_vanboxtel/resources/homo_sapiens.GRCh38.GATK.illumina"
    singularity.enabled = true
    singularity.autoMounts = true
    singularity.runOptions = '-B /hpc -B $TMPDIR:$TMPDIR'
    singularity.cacheDir = '/hpc/local/Rocky8/pmc_vanboxtel/singularity_cache'
  }

  hpc {
    process.executor = 'slurm'
    process.queue = 'cpu'

    singularity.enabled = true
    singularity.autoMounts = true
    singularity.runOptions = '-B /hpc -B $TMPDIR:$TMPDIR'
    singularity.cacheDir = '/hpc/local/Rocky8/pmc_vanboxtel/singularity_cache'
    
    params.resource_dir = "/hpc/pmc_vanboxtel/resources/homo_sapiens.GRCh38.GATK.illumina"

  }

  gcp {
    params.resource_dir = 'gs://pmc-box-pip-resources/resources/homo_sapiens.GRCh38.GATK.illumina'
    params.artifact_registry_path = 'europe-west4-docker.pkg.dev/pmc-gcp-box-d-pip-resources/pipeline-containers'

    gcp_project = getGcpProject()
    gcp_region = 'europe-west4'
    gcp_network = getMetadataNetwork().replaceFirst(/networks/, "global/networks")
    gcp_subnetwork = gcp_network.replace('/global/networks/', "/regions/${gcp_region}/subnetworks/").replace('shared-vpc-', 'subnet-')

    docker.enabled = true
    docker.autoMounts = true
    docker.registry      = 'quay.io'
    process {
    	containerOptions = '-e TMPDIR=/tmp'
    }
    
    process.executor = 'google-batch'
    executor.queueSize = 1000
    execute.pollInterval = '60sec'
    executor.jobName = {
        def safeName = task.name
                    .replaceAll(/[^a-zA-Z0-9-]/, "-") 
                    .take(30)
                    .toLowerCase()
        def safeTag = task.tag
                    .replaceAll(/[^a-zA-Z0-9-]/, "-") 
                    .take(12)
                    .toLowerCase()
      	def safeHash = task.hash.take(8)        
        return "${safeName}-${safeTag}-${safeHash}"
	  }    

    google.region  = "${gcp_region}"
    google.project = "${gcp_project}"
    google.location = "${gcp_region}"
    google.batch.network = "${gcp_network}"
    google.batch.subnetwork = "${gcp_subnetwork}"
    google.batch.serviceAccountEmail = "sa-nextflow-runner@${gcp_project}.iam.gserviceaccount.com"

    // POSSIBLE IMPROVEMENTS:*
    //  google.batch.spot = { task.attempt < 10 ? true : false }
    fusion.enabled = true
    wave.enabled = true
    process.scratch = true

    google.batch.spot = true // Maybe set to false if the other one is turned on
    google.batch.usePrivateAddress = true    
  }

}

report {
  enabled = true
  file = "$params.out_dir/log/nextflow_report.html"
}

trace {
  enabled = true
  overwrite = true 
  file = "$params.out_dir/log/nextflow_trace.txt"
  fields = 'task_id,hash,native_id,process,tag,name,status,exit,module,container,cpus,time,disk,memory,attempt,submit,start,complete,duration,realtime,queue,%cpu,%mem,rss,vmem,peak_rss,peak_vmem,rchar,wchar,syscr,syscw,read_bytes,write_bytes,vol_ctxt,inv_ctxt'
}

timeline {
  enabled = true
  file = "$params.out_dir/log/nextflow_timeline.html"

}

cleanup = true
